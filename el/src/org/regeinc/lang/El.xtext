grammar org.regeinc.lang.El with org.eclipse.xtext.common.Terminals

generate el "http://www.regeinc.org/lang/El"

Model:
	allElement+=Element*;

Element:
	pkg=Package
	allImport+=Import*
	allType+=Type+;

Package:
	'package' name=QualifiedName ';';

/**
 * check: warning on duplicate
 */
Import:
	'import' importedNamespace=QualifiedNameWithWildCard ';';

QualifiedNameWithWildCard:
	QualifiedName '.*'?;

QualifiedName:
	ID (=> '.' ID)*;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';

Type:
	Contract | Entity;

/**
 * check: error on usage of keyword as name
 * check: error on duplicate
 * check: error on extending self
 * check: error on private|protected Visibility
 * check: error on duplicate MethodDeclaration
 * check: error on extending final Contract
 */
Contract:
	visibility=Visibility? 'interface' name=ID (EXTENDS?='extends' type=[Contract|QualifiedName])?
	'{'
	(allMethodDeclaration+=MethodDeclaration ';')*
	'}';

/**
 * check: error on usage of keyword as name
 * check: error on duplicate
 * check: error on coexistence of abstract and final
 * check: error on extending self
 * check: error on implementing duplicate Contract
 * check: error on extending final Entity
 */
Entity:
	visibility=Visibility? (ABSTRACT?='abstract' | FINAL?='final')? 'class' name=ID (EXTENDS?='extends'
	type=[Type|QualifiedName])? (IMPLEMENTS?='implements' allContract+=[Contract|QualifiedName] (','
	allContract+=[Contract|QualifiedName])*)? '{' (allMethodDefinition+=MethodDefinition | allAssociation+=Association |
	allState+=State)* '}';

/**
 * check: error on usage of keyword as name
 * check: error on duplicate State
 * check: error on cyclic reference to self
 */
State:
	'state' name=ID constraint=Constraint? ';';

/**
 * check: error on usage of keyword as name
 * check: error on initializing with different Type
 * check: error on duplicate Association
 */
Association:
	visibility=Visibility? IDENTITY?='identity'?
	specificTypeRef=SpecificTypeRef (constraint=Constraint | (INITIALIZED?='=' instance=Instance))? ';';

/**
 * check: error on usage of keyword as name
 * check: error on usage of containing Type's name
 * check: error on duplicate MethodDeclaration
 */
MethodDeclaration:
	returnType=[Type|QualifiedName]? name=ID '(' (parameter=Parameter)? ')';

/**
 * check: error on usage of keyword as name
 */
Parameter:
	specificTypeRef=SpecificTypeRef (list?=',' next=Parameter)?;

/**
 * check: error on usage of keyword as name
 */
SpecificTypeRef:
	orTypePrefix=OrTypePrefix? typeRef=TypeRef;

/**
 * check: error on usage of keyword as name
 */
TypeRef:
	FINAL?='final'? NOTNULL?='notnull'? type=[Type|QualifiedName] name=ID;

OrTypePrefix:
	andTypePrefix=AndTypePrefix ('||' orTypePrefix=OrTypePrefix)?;

AndTypePrefix:
	notTypePrefix=NotTypePrefix ('&&' andTypePrefix=AndTypePrefix)?;

NotTypePrefix:
	NOT?='!'? typePrefix=TypePrefix;

TypePrefix:
	type=[Type|QualifiedName]
	| '(' orTypePrefix=OrTypePrefix ')';

/**
 * check: error on usage of keyword as name
 * check: error on coexistence of abstract and final
 * check: error on duplicate MethodDefinition
 */
MethodDefinition:
	visibility=Visibility? (ABSTRACT?='abstract' | FINAL?='final')?
	methodDeclaration=MethodDeclaration (UNDEFINED?=';' | (constraint=Constraint? methodBody=MethodBody));

Constraint:
	'onlyif' orCondition=OrCondition;

OrCondition:
	andCondition=AndCondition ('||' orCondition=OrCondition)?;

AndCondition:
	notCondition=NotCondition ('&&' andCondition=AndCondition)?;

NotCondition:
	NOT?='!'? condition=Condition;

/**
 * check: error on usage of non boolean type instance
 * scope: all State, all Association, all Parameter 
 * scope: all public Association.Association, all Association.State, all public Parameter.Association, all Parameter.State 
 */
Condition:
	instance=Instance
	| groupCondition=GroupCondition;

GroupCondition:
	'(' orCondition=OrCondition ')';

MethodBody:
	{MethodBody}
	'{'
	allStatement+=Statement*
	'}';

Statement:
	blockStatement=BlockStatement
	| lineStatement=LineStatement;

BlockStatement:
	ifBlock=If
	| whileBlock=While
	| guardBlock=Guard;

If:
	'if' orCondition=OrCondition methodBody=MethodBody elseBlock=Else?;

Else:
	'else' (ifCondition=If | methodBody=MethodBody);

While:
	'while' orCondition=OrCondition methodBody=MethodBody;

/**
 * check: error on usage of typeRef other than instanceof Guard  
 */
Guard:
	typeRef=[TypeRef] 'guarded' allEntity+=[Entity|QualifiedName] (',' allEntity+=[Entity|QualifiedName])*
	methodBody=MethodBody;

/**
 * scope: let expression not allowed outside of containing LineStatement
 */
LineStatement:
	(doWhere=DoWhere
	| (LETEXPRESSION?='let' localVariableBinding=LocalVariableBinding 'in' doWhere=DoWhere)) ';';

LocalVariableBinding:
	localVariableDeclaration=LocalVariableDeclaration (list?=',' next=LocalVariableBinding)?;

LocalVariableDeclaration:
	specificTypeRef=SpecificTypeRef '=' instance=Instance;

DoWhere:
	doIf=DoIf (CONTEXTUAL?='where' where=Where)?;

Where:
	clause=Clause (NESTED?='and' where=Where)?;

/**
 * check: error on usage of instance other than instanceof List
 */
Clause:
	(typeRef=TypeRef 'from' instance=Instance) // only list instance
	| orCondition=OrCondition;

DoIf:
	instruction=Instruction (CONDITIONAL?='provided' provided=Provided)?;

Provided:
	orCondition=OrCondition (ALTERNATE?='otherwise' doIf=DoIf)?;

/**
 * check: error on usage of passive Instance in isolation
 */
Instruction:
	((((specificTypeRef=SpecificTypeRef | typeRef=[TypeRef]) ASSIGNMENT?='=') | PRINT?='print' | RETURN?='return')?
	instance=Instance) | (BREAK?='break' | CONTINUE?='continue');

/**
 * check: error on trying to access state.property
 * scope: all public Association as referredStateOrVariable upon referred by typeRef
 */
Instance:
	((stateOrVariable=[StateOrVariable|ID] (=> '.' referredStateOrVariable=[StateOrVariable|ID])?)
	| literal=Literal | newInstance=NewInstance | listInstance=ListInstance) (dotMethodCall=DotMethodCall |
	operatorCall=OperatorCall)?;

StateOrVariable:
	TypeRef | State;

ListInstance:
	{ListInstance} ('[' argument=Argument? ']');

NewInstance:
	'new' entity=[Entity|QualifiedName] '(' argument=Argument? ')' (=> '{' allNestedInstance+=NestedInstance+ '}')?;

NestedInstance:
	specificTypeRef=[SpecificTypeRef|QualifiedName] '=' instance=Instance ';';

MethodCall:
	methodDeclaration=[MethodDeclaration|QualifiedName] '(' argument=Argument? ')';

DotMethodCall:
	'.' methodCall=MethodCall (dotMethodCall=DotMethodCall | operatorCall=OperatorCall)?;

Argument:
	instance=Instance (list?=',' next=Argument)?;

OperatorCall:
	=> operator=Operator instance=Instance (operatorCall=OperatorCall)?;

enum Operator:
	ADD='+' | SUBSTRACT='-' | MULTIPLY='*' | DIVISION='%' | SAME='==' | NOTSAME='!=' | GREATERTHAN='>' |
	LESSTHAN='<' | LESSTHANOREQUALTO='<=' | GREATERTHANOREQUALTO='>=' | ONEOF='oneof' | IS='is' | HAS='has' |
	TYPEOF='instanceof';

Literal:
	THIS='this' | TRUE='true' | FALSE='false' | NULL='null' | number=DECIMAL_LITERAL | string=STRING;

DECIMAL_LITERAL:
	integer=INT ((PERIOD?='.' fraction=INT (FLOATING?=('f' | 'F'))?) | TOOLONG?=('l' | 'L'))?;

