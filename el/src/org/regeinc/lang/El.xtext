grammar org.regeinc.lang.El with org.eclipse.xtext.common.Terminals

generate el "http://www.regeinc.org/lang/El"

Model:
	allElement+=Element*;

Element:
	pkg=Package
	allImport+=Import*
	allType+=Type+;

Package:
	'package' name=QualifiedName ';';

	/**
 * check: warning on duplicate
 */
Import:
	'import' importedNamespace=QualifiedNameWithWildCard ';';

QualifiedNameWithWildCard:
	QualifiedName '.*'?;

QualifiedName:
	ID (=> '.' ID)*;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';

Type:
	Contract | Entity;

	/**
 * check: error on usage of keyword as name
 * check: error on duplicate
 * check: error on extending self
 * check: error on private|protected Visibility
 * check: error on duplicate MethodDeclaration
 * check: error on extending final Contract
 */
Contract:
	visibility=Visibility? 'interface' name=ID (EXTENDS?='extends' type=[Contract|QualifiedName])?
	'{'
	(allMethodDeclaration+=MethodDeclaration ';')*
	'}';

	/**
 * check: error on usage of keyword as name
 * check: error on duplicate
 * check: error on coexistence of abstract and final
 * check: error on extending self
 * check: error on implementing duplicate Contract
 * check: error on extending final Entity
 */
Entity:
	visibility=Visibility? (ABSTRACT?='abstract' | FINAL?='final')? 'class' name=ID (EXTENDS?='extends'
	type=[Type|QualifiedName])? (IMPLEMENTS?='implements' allContract+=[Contract|QualifiedName] (','
	allContract+=[Contract|QualifiedName])*)?
	'{'
	(allMethodDefinition+=MethodDefinition | allAssociation+=Association | allState+=State)*
	'}';

	/**
 * check: error on usage of keyword as name
 * check: error on duplicate State
 * check: error on cyclic reference to self
 */
State:
	'state' name=ID constraint=Constraint? ';';

	/**
 * check: error on usage of keyword as name
 * check: error on initializing with different Type
 * check: error on duplicate Association
 */
Association:
	visibility=Visibility? IDENTITY?='identity'?
	specificTypeRef=SpecificTypeRef (constraint=Constraint | (INITIALIZED?='=' expression=Expression))? ';';

	/**
 * check: error on usage of keyword as name
 * check: error on usage of containing Type's name
 * check: error on duplicate MethodDeclaration
 */
MethodDeclaration:
	returnType=[Type|QualifiedName]? name=ID '(' (parameter=Parameter)? ')';

	/**
 * check: error on usage of keyword as name
 */
Parameter:
	specificTypeRef=SpecificTypeRef (list?=',' next=Parameter)?;

	/**
 * check: error on usage of keyword as name
 */
SpecificTypeRef:
	typePrefix=TypePrefix? typeRef=TypeRef;

	/**
 * check: error on usage of keyword as name
 */
TypeRef:
	FINAL?='final'? NOTNULL?='notnull'? type=[Type|QualifiedName] name=ID;

TypePrefix:
	andPrefix=AndPrefix ('||' typePrefix=TypePrefix)?;

AndPrefix:
	notPrefix=NotPrefix ('&&' andPrefix=AndPrefix)?;

NotPrefix:
	NOT?='!'? (type=[Type|QualifiedName]
	| '(' typePrefix=TypePrefix ')');

	/**
 * check: error on usage of keyword as name
 * check: error on coexistence of abstract and final
 * check: error on duplicate MethodDefinition
 */
MethodDefinition:
	visibility=Visibility? (ABSTRACT?='abstract' | FINAL?='final')?
	methodDeclaration=MethodDeclaration (UNDEFINED?=';' | (constraint=Constraint? methodBody=MethodBody));

Constraint:
	'onlyif' condition=Condition;

Condition:
	and=And (OR?='||' condition=Condition)?;

And:
	not=Not ('&&' and=And)?;

Not:
	NOT?='!'? (comparison=Comparison | groupCondition=GroupCondition);

	/**
 * check: error on usage of non boolean Expression
 * scope: all State, all Association, all Parameter 
 * scope: all public Association.Association, all Association.State, all public Parameter.Association, all Parameter.State 
 */
Comparison:
	expression=Expression ((=> (EQUAL?='==' | NOTEQUAL?='!=' | LESSTHAN?='<' | GREATERTHAN?='>' | LESSTHANOREQUAL?='<=' |
	GREATERTHANOREQUAL?='>=' | IN?='in') rExpression=Expression)
	| IS?='is' state=[State|QualifiedName]
	| TYPEOF?='instanceof' type=[Type|QualifiedName])?;

GroupCondition:
	'(' condition=Condition ')';

MethodBody:
	{MethodBody}
	'{'
	allStatement+=Statement*
	'}';

Statement:
	blockStatement=BlockStatement
	| lineStatement=LineStatement;

BlockStatement:
	ifBlock=If
	| whileBlock=While
	| guardBlock=Guard;

If:
	'if' condition=Condition methodBody=MethodBody elseBlock=Else?;

Else:
	'else' (ifCondition=If | methodBody=MethodBody);

While:
	'while' condition=Condition methodBody=MethodBody;

	/**
 * check: error on usage of typeRef other than instanceof Guard  
 */
Guard:
	typeRef=[TypeRef] 'guarded' allEntity+=[Entity|QualifiedName] (',' allEntity+=[Entity|QualifiedName])*
	methodBody=MethodBody;

	/**
 * scope: let expression not allowed outside of containing LineStatement
 */
LineStatement:
	(doWhere=DoWhere
	| (LETEXPRESSION?='let' localVariableBinding=LocalVariableBinding 'in' doWhere=DoWhere)) ';';

LocalVariableBinding:
	localVariableDeclaration=LocalVariableDeclaration (list?=',' next=LocalVariableBinding)?;

LocalVariableDeclaration:
	specificTypeRef=SpecificTypeRef '=' expression=Expression;

DoWhere:
	doIf=DoIf (CONTEXTUAL?='where' where=Where)?;

Where:
	clause=Clause (NESTED?='and' where=Where)?;

	/**
 * check: error on usage of instance other than instanceof List
 */
Clause:
	(=> typeRef=TypeRef 'from' expression=Expression) // only list instance
	| condition=Condition;

DoIf:
	instruction=Instruction (CONDITIONAL?='provided' provided=Provided)?;

Provided:
	condition=Condition (ALTERNATE?='otherwise' doIf=DoIf)?;

	/**
 * check: error on usage of passive Instance in isolation
 * check: error on usage of MOVE when rExpression is not a value
 * check: error on usage of COPY when LHS.Type != RHS.Type
 */
Instruction:
	(expression=Expression ((COPY='=' | MOVE='=~') rExpression=Expression)?)
	| BREAK?='break' | CONTINUE?='continue' | ((RETURN?='return' | PRINT?='print') expression=Expression);

	/**
  * check: error on trying to access state.property
 */
Expression:
	instance=Instance (=> operator=Operator expression=Expression)?;

enum Operator:
	ADD='+' | SUBSTRACT='-' | PRODUCT='*' | DIVISION='%' | DOT='.';
	
	/**
 * scope: all public Association as referredStateOrVariable upon referred by typeRef
 */
Instance:
	(stateOrTypeRef=[StateOrTypeRef|QualifiedName] | => methodCall=MethodCall | literal=Literal | newInstance=NewInstance |
	listInstance=ListInstance);

StateOrTypeRef:
	TypeRef | State;

MethodCall:
	methodDeclaration=[MethodDeclaration|QualifiedName] '(' argument=Argument? ')';

Argument:
	expression=Expression (list?=',' next=Argument)?;

Literal:
	THIS='this' | TRUE='true' | FALSE='false' | NULL='null' | number=DECIMAL_LITERAL | string=STRING;

DECIMAL_LITERAL:
	integer=INT ((=> PERIOD?='.' fraction=INT (FLOATING?=('f' | 'F'))?) | TOOLONG?=('l' | 'L'))?;

ListInstance:
	{ListInstance} ('[' argument=Argument? ']');

NewInstance:
	'new' entity=[Entity|QualifiedName] '(' argument=Argument? ')' (=> '{' allNestedInstance+=NestedInstance+ '}')?;

NestedInstance:
	specificTypeRef=[SpecificTypeRef|QualifiedName] '=' expression=Expression ';';
