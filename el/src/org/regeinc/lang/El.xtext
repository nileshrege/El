grammar org.regeinc.lang.El with org.eclipse.xtext.common.Terminals

generate el "http://www.regeinc.org/lang/El"

Model:
	allElement+=Element*;

Element:
	pkg=Package
	allImport+=Import*
	allType+=Type+;

Package:
	'package' name=QualifiedName ';';

	/**
 * check: warning on duplicate
 */
Import:
	'import' importedNamespace=QualifiedNameWithWildCard ';';

QualifiedNameWithWildCard:
	QualifiedName '.*'?;

QualifiedName:
	ID (=> '.' ID)*;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';

Type:
	Contract | Entity;

	/**
 * check: error on usage of keyword as name
 * check: error on duplicate
 * check: error on extending self
 * check: error on private|protected Visibility
 * check: error on duplicate MethodDeclaration
 * check: error on extending final Contract
 */
Contract:
	visibility=Visibility? 'interface' name=ID (EXTENDS?='extends' type=[Contract|QualifiedName])?
	'{'
	(allMethodDeclaration+=MethodDeclaration ';')*
	'}';

	/**
 * check: error on usage of keyword as name
 * check: error on duplicate
 * check: error on coexistence of abstract and final
 * check: error on extending self
 * check: error on implementing duplicate Contract
 * check: error on extending final Entity
 */
Entity:
	visibility=Visibility? (ABSTRACT?='abstract' | FINAL?='final')? 'class' name=ID (EXTENDS?='extends'
	type=[Type|QualifiedName])? (IMPLEMENTS?='implements' allContract+=[Contract|QualifiedName] (','
	allContract+=[Contract|QualifiedName])*)?
	'{'
	(allMethodDefinition+=MethodDefinition | allAssociation+=Association | allState+=State)*
	'}';

	/**
 * check: error on usage of keyword as name
 * check: error on duplicate State
 * check: error on cyclic reference to self
 */
State:
	'state' name=ID constraint=Constraint? ';';

	/**
 * check: error on usage of keyword as name
 * check: error on initializing with different Type
 * check: error on duplicate Association
 */
Association:
	visibility=Visibility? IDENTITY?='identity'?
	qualifiedReference=QualifiedReference (constraint=Constraint | (INITIALIZED?='=' expression=Expression))? ';';

	/**
 * check: error on usage of keyword as name
 * check: error on usage of containing Type's name
 * check: error on duplicate MethodDeclaration
 */
MethodDeclaration:
	returnType=[Type|QualifiedName]? name=ID '(' (parameter=Parameter)? ')';

	/**
 * check: error on usage of keyword as name
 */
Parameter:
	reference=Reference (list?=',' next=Parameter)?;

	/**
 * check: error on usage of keyword as name
 */
QualifiedReference:
	typePrefix=TypePrefix? reference=Reference;

	/**
 * check: error on usage of keyword as name
 */
Reference:
	FINAL?='final'? NOTNULL?='notnull'? type=[Type|QualifiedName] name=ID;

TypePrefix:
	andPrefix=AndPrefix ('||' typePrefix=TypePrefix)?;

AndPrefix:
	notPrefix=NotPrefix ('&&' andPrefix=AndPrefix)?;

NotPrefix:
	NOT?='!'? (type=[Type|QualifiedName]
	| '(' typePrefix=TypePrefix ')');

	/**
 * check: error on usage of keyword as name
 * check: error on coexistence of abstract and final
 * check: error on duplicate MethodDefinition
 */
MethodDefinition:
	visibility=Visibility? (ABSTRACT?='abstract' | FINAL?='final')?
	methodDeclaration=MethodDeclaration ((constraint=Constraint? methodBody=MethodBody) | UNDEFINED?=';');

Constraint:
	'onlyif' condition=Condition;

Condition:
	andCondition=AndCondition (OR?='||' condition=Condition)?;

AndCondition:
	notCondition=NotCondition (AND?='&&' andCondition=AndCondition)?;

NotCondition:
	NOT?='!'? (comparison=Comparison | (=> '(' groupCondition=Condition ')'));

	/**
 * check: error on usage of non boolean Expression
 * scope: all State, all Association, all Parameter 
 * scope: all public Association.Association, all Association.State, all public Parameter.Association, all Parameter.State 
 */
Comparison:
	(expression=Expression (stateComparison=StateComparison | typeComparison=TypeComparison |
	associativeComparison=AssociativeComparison)?);

StateComparison:
	IS?='is' state=[State|QualifiedName];

TypeComparison:
	TYPEOF?='instanceof' type=[Type|QualifiedName];

AssociativeComparison:
	comparator=Comparator expression=Expression;

enum Comparator:
	EQUAL='==' | NOTEQUAL='!=' | LESSTHAN='<' | GREATERTHAN='>' | LESSTHANOREQUAL='<=' | GREATERTHANOREQUAL='>=' |
	IN='in' | MATCH='?=';

MethodBody:
	{MethodBody}
	'{'
	allStatement+=Statement*
	'}';

	/**
 * check: error on absence of LineStatement for NON void methods
 */
Statement:
	blockStatement=BlockStatement
	| lineStatement=LineStatement;

BlockStatement:
	ifBlock=If
	| whileBlock=While
	| forBlock=For
	| guardBlock=Guard;

If:
	'if' condition=Condition methodBody=MethodBody elseBlock=Else?;

Else:
	'else' (ifCondition=If | methodBody=MethodBody);

While:
	'while' condition=Condition methodBody=MethodBody;

For:
	'for' '(' ((reference=Reference ':' (listInstance=ListInstance | listReference=[Reference])) 
		| (localVariableDeclaration=LocalVariableDeclaration? ';' condition=Condition? ';' expression=Expression?))')' 
		methodBody=MethodBody;

	/**
 * check: error on usage of typeRef other than instanceof Guard  
 */
Guard:
	reference=[Reference] 'guarded' allEntity+=[Entity|QualifiedName] (',' allEntity+=[Entity|QualifiedName])*
	methodBody=MethodBody;

	/**
 * scope: let expression not allowed outside of containing LineStatement
 */
LineStatement:
	(doWhere=DoWhere
	| (LETEXPRESSION?='let' localVariableBinding=LocalVariableBinding 'in' doWhere=DoWhere)) ';';

LocalVariableBinding:
	localVariableDeclaration=LocalVariableDeclaration (list?=',' next=LocalVariableBinding)?;

LocalVariableDeclaration:
	qualifiedReference=QualifiedReference '=' expression=Expression;

DoWhere:
	doIf=DoIf (CONTEXTUAL?='where' where=Where)?;

Where:
	clause=Clause (NESTED?='and' where=Where)?;

	/**
 * check: error on usage of instance other than instanceof List
 */
Clause:
	(=> reference=Reference 'from' expression=Expression) // only list instance
	| condition=Condition;

DoIf:
	instruction=Instruction (CONDITIONAL?='provided' provided=Provided)?;

Provided:
	condition=Condition (ALTERNATE?='otherwise' doIf=DoIf)?;

	/**
 * check: error on usage of passive Instance in isolation
 * check: error on usage of MOVE when rExpression is not a value
 * check: error on usage of COPY when LHS.Type != RHS.Type
 */
Instruction:
	(BREAK?='break' | CONTINUE?='continue')
	| (((=> reference=[Reference|QualifiedName] COPY?='=') | (RETURN?='return' | PRINT?='print'))? expression=Expression);

	/**
 * check: error on usage of ASTERIX if LHS is not numeric
 */
Expression:
	division=Division (ASTERIX?='*' expression=Expression)?;

	/**
 * check: error on usage of PERCENT if LHS is not numeric
 */
Division:
	addition=Addition (PERCENT?='%' division=Division)?;

	/**
 * check: error on usage of PLUS if LHS is not numeric
 */
Addition:
	substraction=Substraction (PLUS?='+' addition=Addition)?;

	/**
 * check: error on usage of HYPHEN if LHS is not numeric
 */
Substraction:
	instance=Instance (HYPHEN?='-' substraction=Substraction)?;

	/**
 * scope: MethodCall must belong to the LHS of DOT
 */
Instance:
	((literal=Literal | newInstance=NewInstance | listInstance=ListInstance | reference=[Reference]) ('.'
	methodCall=MethodCall)?)
	| '(' groupExpression=Expression ')';

	/**
 * scope: MethodCall must belong to the LHS of DOT
 */
MethodCall:
	(reference=[Reference]
	| (=> methodDeclaration=[MethodDeclaration|QualifiedName] => '(' argument=Argument? ')')) ('.'
	methodCall=MethodCall)?;

Argument:
	expression=Expression (list?=',' next=Argument)?;

Literal:
	THIS='this' | TRUE='true' | FALSE='false' | NULL='null' | number=DECIMAL_LITERAL | string=STRING;

DECIMAL_LITERAL:
	integer=INT ((=> PERIOD?='.' fraction=INT (FLOATING?=('f' | 'F'))?) | TOOLONG?=('l' | 'L'))?;

ListInstance:
	{ListInstance} ('[' ( select=Select | argument=Argument)? ']');

Select:
	'select' (DISTINCT?='distinct')? reference=Reference 
		'from' (listReference=[Reference] | listInstance=ListInstance) 
			(CLAUSE?='where' condition=Condition)?;

NewInstance:
	'new' entity=[Entity|QualifiedName] '(' argument=Argument? ')' (=> '{' allNestedInstance+=NestedInstance+ '}')?;

NestedInstance:
	qualifiedReference=[QualifiedReference|QualifiedName] '=' expression=Expression ';';
